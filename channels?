# Yes! Here's How the Notification System Works

The bot has a **built-in notification system** that triggers whenever new "car audio" posts are found. Here's what's included and how to extend it:

---

## ‚úÖ Built-In Notification Methods

### 1. **Discord Push Notifications**
```
Real-time alerts sent to any Discord channel via webhook
‚Üí Shows up as push notifications on your phone if Discord is installed
```

### 2. **Email Digests**
```
HTML-formatted email sent via SMTP (Gmail, Outlook, etc.)
‚Üí Get email alerts every time new posts are detected
```

### 3. **Console Output**
```
Colored, formatted terminal output for real-time monitoring
```

---

## üîß Adding More Notification Types

You can easily extend the `notifier.py` to add more channels. Here's an expanded version with **several additional options**:

### Updated `notifier.py`
```python
import smtplib
import json
import requests
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
from config import Config


class Notifier:
    def __init__(self):
        self.discord_url = Config.DISCORD_WEBHOOK_URL
        self.email_configured = all([
            Config.EMAIL_SENDER,
            Config.EMAIL_PASSWORD,
            Config.EMAIL_RECIPIENT,
        ])
        # Add new notification channels
        self.pushover_configured = all([
            getattr(Config, 'PUSHOVER_USER_KEY', None),
            getattr(Config, 'PUSHOVER_API_TOKEN', None),
        ])
        self.slack_url = getattr(Config, 'SLACK_WEBHOOK_URL', None)
        self.telegram_configured = all([
            getattr(Config, 'TELEGRAM_BOT_TOKEN', None),
            getattr(Config, 'TELEGRAM_CHAT_ID', None),
        ])
        self.twilio_configured = all([
            getattr(Config, 'TWILIO_ACCOUNT_SID', None),
            getattr(Config, 'TWILIO_AUTH_TOKEN', None),
            getattr(Config, 'TWILIO_FROM_NUMBER', None),
            getattr(Config, 'TWILIO_TO_NUMBER', None),
        ])

    def notify(self, posts: list):
        """Send notifications through ALL configured channels."""
        if not posts:
            return

        # Always print to console
        self._print_posts(posts)

        # Trigger all configured channels
        if self.discord_url:
            self._send_discord(posts)

        if self.email_configured:
            self._send_email(posts)

        if self.pushover_configured:
            self._send_pushover(posts)

        if self.slack_url:
            self._send_slack(posts)

        if self.telegram_configured:
            self._send_telegram(posts)

        if self.twilio_configured:
            self._send_sms(posts)

    # =========================================================
    # üì± PUSHOVER - Real Push Notifications to Phone
    # =========================================================
    def _send_pushover(self, posts: list):
        """
        Send real push notifications to iOS/Android via Pushover.
        Setup: https://pushover.net/ ($5 one-time purchase)
        """
        try:
            for post in posts[:5]:  # Limit to avoid spam
                data = {
                    "token": Config.PUSHOVER_API_TOKEN,
                    "user": Config.PUSHOVER_USER_KEY,
                    "title": f"üîä Car Audio - {post['platform'].upper()}",
                    "message": (
                        f"{post['title'][:200]}\n\n"
                        f"By: {post['author']}\n"
                        f"Source: {post['source']}"
                    ),
                    "url": post["url"],
                    "url_title": "View Post",
                    "priority": 0,  # -2 to 2 (2 = emergency)
                    "sound": "pushover",
                }

                response = requests.post(
                    "https://api.pushover.net/1/messages.json",
                    data=data,
                    timeout=10,
                )
                if response.status_code == 200:
                    print(f"[Pushover] ‚úÖ Notification sent")
                else:
                    print(f"[Pushover] ‚ö†Ô∏è Error: {response.text}")

        except Exception as e:
            print(f"[Pushover] ‚ùå Error: {e}")

    # =========================================================
    # üí¨ SLACK - Workspace Notifications
    # =========================================================
    def _send_slack(self, posts: list):
        """Send to Slack channel via webhook."""
        try:
            blocks = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": f"üîä {len(posts)} new Car Audio posts found",
                    }
                }
            ]

            for post in posts[:10]:
                emoji = {
                    "reddit": "üü†", "facebook": "üîµ", "instagram": "üü£"
                }.get(post["platform"], "üìù")

                blocks.append({
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": (
                            f"{emoji} *{post['platform'].upper()}* | {post['source']}\n"
                            f"*<{post['url']}|{post['title'][:100]}>*\n"
                            f"By: {post['author']}"
                        ),
                    }
                })
                blocks.append({"type": "divider"})

            response = requests.post(
                self.slack_url,
                json={"blocks": blocks},
                timeout=10,
            )
            if response.status_code == 200:
                print(f"[Slack] ‚úÖ Sent {len(posts)} posts")
            else:
                print(f"[Slack] ‚ö†Ô∏è Error: {response.status_code}")

        except Exception as e:
            print(f"[Slack] ‚ùå Error: {e}")

    # =========================================================
    # ‚úàÔ∏è TELEGRAM - Bot Notifications
    # =========================================================
    def _send_telegram(self, posts: list):
        """
        Send via Telegram bot.
        Setup:
          1. Message @BotFather to create a bot
          2. Get your chat_id from @userinfobot
        """
        try:
            bot_token = Config.TELEGRAM_BOT_TOKEN
            chat_id = Config.TELEGRAM_CHAT_ID

            for post in posts[:10]:
                emoji = {
                    "reddit": "üü†", "facebook": "üîµ", "instagram": "üü£"
                }.get(post["platform"], "üìù")

                text = (
                    f"{emoji} <b>Car Audio Alert - {post['platform'].upper()}</b>\n\n"
                    f"üìå <b>{post['title'][:200]}</b>\n"
                    f"üë§ {post['author']}\n"
                    f"üìç {post['source']}\n\n"
                    f"üîó <a href=\"{post['url']}\">View Post</a>"
                )

                response = requests.post(
                    f"https://api.telegram.org/bot{bot_token}/sendMessage",
                    json={
                        "chat_id": chat_id,
                        "text": text,
                        "parse_mode": "HTML",
                        "disable_web_page_preview": False,
                    },
                    timeout=10,
                )
                if response.status_code == 200:
                    print(f"[Telegram] ‚úÖ Message sent")
                else:
                    print(f"[Telegram] ‚ö†Ô∏è Error: {response.json()}")

        except Exception as e:
            print(f"[Telegram] ‚ùå Error: {e}")

    # =========================================================
    # üì≤ SMS via Twilio
    # =========================================================
    def _send_sms(self, posts: list):
        """Send SMS text message via Twilio."""
        try:
            from twilio.rest import Client

            client = Client(Config.TWILIO_ACCOUNT_SID, Config.TWILIO_AUTH_TOKEN)

            # Combine into one SMS (160 char limit per segment)
            body = f"üîä {len(posts)} new Car Audio posts!\n\n"
            for post in posts[:3]:
                body += f"[{post['platform'].upper()}] {post['title'][:60]}\n"

            message = client.messages.create(
                body=body[:1600],
                from_=Config.TWILIO_FROM_NUMBER,
                to=Config.TWILIO_TO_NUMBER,
            )

            print(f"[SMS] ‚úÖ Sent: {message.sid}")

        except Exception as e:
            print(f"[SMS] ‚ùå Error: {e}")

    # =========================================================
    # ü™ù GENERIC WEBHOOK - Connect to ANYTHING
    # =========================================================
    def _send_webhook(self, posts: list):
        """
        Send to any custom webhook URL (Zapier, IFTTT, Make, n8n, etc.)
        This lets you trigger ANYTHING:
          - Smart home actions
          - Google Sheets logging
          - CRM updates
          - Custom apps
        """
        try:
            webhook_url = getattr(Config, 'CUSTOM_WEBHOOK_URL', None)
            if not webhook_url:
                return

            payload = {
                "event": "car_audio_posts_found",
                "count": len(posts),
                "timestamp": datetime.utcnow().isoformat(),
                "posts": [
                    {
                        "platform": p["platform"],
                        "title": p["title"],
                        "author": p["author"],
                        "url": p["url"],
                        "source": p["source"],
                    }
                    for p in posts
                ],
            }

            response = requests.post(
                webhook_url,
                json=payload,
                timeout=10,
            )
            print(f"[Webhook] ‚úÖ Sent ({response.status_code})")

        except Exception as e:
            print(f"[Webhook] ‚ùå Error: {e}")

    # =========================================================
    # Existing methods (email, discord, console)
    # =========================================================
    def _print_posts(self, posts: list):
        print("\n" + "=" * 70)
        print(f"üì¢ {len(posts)} NEW 'CAR AUDIO' POSTS FOUND")
        print("=" * 70)
        for post in posts:
            emoji = {"reddit": "üü†", "facebook": "üîµ", "instagram": "üü£"}.get(post["platform"], "üìù")
            print(f"\n{emoji} [{post['platform'].upper()}] {post['source']}")
            print(f"   üìå {post['title'][:100]}")
            print(f"   üë§ {post['author']}")
            print(f"   üîó {post['url']}")

    def _send_discord(self, posts: list):
        try:
            for post in posts[:10]:
                embed = {
                    "embeds": [{
                        "title": f"üîä {post['title'][:256]}",
                        "description": (post.get("content", "")[:1000] or "No content"),
                        "url": post["url"],
                        "color": {"reddit": 0xFF4500, "facebook": 0x1877F2, "instagram": 0xE1306C}.get(post["platform"], 0x808080),
                        "fields": [
                            {"name": "Platform", "value": post["platform"].upper(), "inline": True},
                            {"name": "Author", "value": post["author"], "inline": True},
                            {"name": "Source", "value": post["source"], "inline": True},
                        ],
                    }]
                }
                requests.post(self.discord_url, json=embed, timeout=10)
            print(f"[Discord] ‚úÖ Sent {min(len(posts), 10)} notifications")
        except Exception as e:
            print(f"[Discord] ‚ùå Error: {e}")

    def _send_email(self, posts: list):
        try:
            msg = MIMEMultipart("alternative")
            msg["Subject"] = f"üîä Car Audio Monitor: {len(posts)} new posts"
            msg["From"] = Config.EMAIL_SENDER
            msg["To"] = Config.EMAIL_RECIPIENT

            rows = ""
            for post in posts:
                rows += f"<tr><td><strong>{post['platform'].upper()}</strong></td>"
                rows += f"<td><a href='{post['url']}'>{post['title'][:100]}</a> by {post['author']}</td></tr>"

            html = f"<html><body><h2>üîä {len(posts)} New Car Audio Posts</h2><table>{rows}</table></body></html>"
            msg.attach(MIMEText(html, "html"))

            with smtplib.SMTP(Config.SMTP_SERVER, Config.SMTP_PORT) as server:
                server.starttls()
                server.login(Config.EMAIL_SENDER, Config.EMAIL_PASSWORD)
                server.send_message(msg)
            print(f"[Email] ‚úÖ Sent to {Config.EMAIL_RECIPIENT}")
        except Exception as e:
            print(f"[Email] ‚ùå Error: {e}")
```

### Updated `.env` with all notification options
```env
# ============ NOTIFICATIONS ============

# Discord
DISCORD_WEBHOOK_URL=

# Email
EMAIL_SENDER=your_email@gmail.com
EMAIL_PASSWORD=your_app_password
EMAIL_RECIPIENT=you@email.com
SMTP_SERVER=smtp.gmail.com
SMTP_PORT=587

# Pushover (real push notifications - iOS/Android)
PUSHOVER_USER_KEY=
PUSHOVER_API_TOKEN=

# Slack
SLACK_WEBHOOK_URL=

# Telegram
TELEGRAM_BOT_TOKEN=
TELEGRAM_CHAT_ID=

# Twilio SMS
TWILIO_ACCOUNT_SID=
TWILIO_AUTH_TOKEN=
TWILIO_FROM_NUMBER=+1234567890
TWILIO_TO_NUMBER=+1234567890

# Custom Webhook (Zapier, IFTTT, Make, n8n, etc.)
CUSTOM_WEBHOOK_URL=
```

---

## Summary of All Notification Options

| Method | Best For | Cost | Setup Difficulty |
|--------|----------|------|-----------------|
| **üìß Email** | Digests, records | Free | Easy |
| **üí¨ Discord** | Real-time alerts | Free | Easy |
| **üì± Pushover** | Phone push notifications | $5 one-time | Easy |
| **‚úàÔ∏è Telegram** | Phone push notifications | Free | Easy |
| **üíº Slack** | Team/workspace alerts | Free | Easy |
| **üì≤ SMS (Twilio)** | Text messages | ~$0.01/msg | Medium |
| **ü™ù Custom Webhook** | Connect to anything (Zapier, IFTTT, Google Sheets, etc.) | Varies | Medium |

**Just fill in the credentials in `.env` for whichever channels you want ‚Äî the bot auto-detects which ones are configured and uses them all!**
